<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 6 bits blog</title>
    <link>https://blog.take4s5i.dev/posts/</link>
    <description>Recent content in Posts on 6 bits blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sat, 29 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.take4s5i.dev/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Rust] 並列処理に使うAPIたち2(Once, channel)</title>
      <link>https://blog.take4s5i.dev/posts/2022/rust-std-sync2/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.take4s5i.dev/posts/2022/rust-std-sync2/</guid>
      <description>前回の続きで Once と mpsc を調べていきます。
Once Once は static 変数の初期化に利用できます。
Once を使うことで、複数スレッドから同時に初期処理が実行されても、一度だけ実行されることを保証できます。
use std::collections::HashMap; use std::sync::Once; use std::thread; static mut CONFIG: Option&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt; = None; static START: Once = Once::new(); fn get_config(key: &amp;amp;str) -&amp;gt; Option&amp;lt;String&amp;gt; { unsafe { START.call_once(|| { println!(&amp;#34;call_once&amp;#34;); CONFIG = Some(HashMap::new()); CONFIG .as_mut() .unwrap() .insert(&amp;#34;hoge&amp;#34;.to_owned(), &amp;#34;12345&amp;#34;.to_owned()); }); CONFIG.as_ref().unwrap().get(key).map(|v| v.clone()) } } fn main() { let mut handles = Vec::new(); for i in 0..10 { handles.push(thread::spawn(move || { println!</description>
    </item>
    
    <item>
      <title>Elastic Searchのobject, flattened, nestedの違い</title>
      <link>https://blog.take4s5i.dev/posts/2022/elastic-search-object-types/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.take4s5i.dev/posts/2022/elastic-search-object-types/</guid>
      <description>Elastic Search の object 系の type について調べたのでまとめていきます。
object objectは JSON のオブジェクトなどの データ構造をインデックスするのに使える型です。
{ &amp;#34;user&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;tanaka&amp;#34;, &amp;#34;age&amp;#34;: 20 } } このようなオブジェクトがあった場合
{ &amp;#34;user.name&amp;#34;: &amp;#34;tanaka&amp;#34;, &amp;#34;user.age&amp;#34;: 20 } のようにフラットにされてインデックスされます。
オブジェクトにすることでパフォーマンス的なデメリットは特になさそうだったので、 単純にフィールドを構造化して整理するのに利用すると良さそうです。
ただし、オブジェクトの配列を持つ場合はおそらく意図した挙動にならないので注意が必要です。
例えば以下のようなデータがあったとします
{ &amp;#34;skills&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;ElasticSearch&amp;#34;, &amp;#34;level&amp;#34;: &amp;#34;newbie&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;Typescript&amp;#34;, &amp;#34;level&amp;#34;: &amp;#34;advanced&amp;#34; } ] } これは次のようにインデックスされます。
{ &amp;#34;skills.name&amp;#34;: [&amp;#34;ElasticSearch&amp;#34;, &amp;#34;Typescript&amp;#34;], &amp;#34;skills.level&amp;#34;: [&amp;#34;newbie&amp;#34;, &amp;#34;advanced&amp;#34;] } フラットにされてしまうことで、name と level の関係性が失われてしまいます。
{ &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;must&amp;#34;: [ { &amp;#34;term&amp;#34;: { &amp;#34;skills.</description>
    </item>
    
    <item>
      <title>[Rust] 並列処理に使うAPIたち(Mutex, RwLock, Barrier, Condvar)</title>
      <link>https://blog.take4s5i.dev/posts/2022/rust-std-sync/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.take4s5i.dev/posts/2022/rust-std-sync/</guid>
      <description>最近業務でgoで並列処理を書くことがあり、Rustの場合はどうなっているのか気になったので調べてみました。
std::syncモジュールの中をいろいろ見ていきたいと思います。
Mutex まずは基本のMutexから。
RustのMutexは単にロックを制御するだけではなく、ロックで守られたデータを持つことができます。 （データが不要で単にロックだけほしい場合はユニット型()を使えばよいですね）
Mutexでカウンタをつくり、 4スレッド起動し、各スレッドで100回インクリメントを行います。 cntは400になるはずです。
use std::sync::{Arc, Mutex, MutexGuard}; use std::thread; const N_THREADS: usize = 4; fn main() { let mut handles: Vec&amp;lt;thread::JoinHandle&amp;lt;_&amp;gt;&amp;gt; = Vec::with_capacity(N_THREADS); let mutex: Arc&amp;lt;Mutex&amp;lt;usize&amp;gt;&amp;gt; = Arc::new(Mutex::new(0)); for _ in 0..N_THREADS { let mutex = mutex.clone(); let handle = thread::spawn(move || { for _ in 0..100 { let mut cnt: MutexGuard&amp;lt;_&amp;gt; = mutex.lock().unwrap(); *cnt += 1; } }); handles.push(handle); } while let Some(handle) = handles.</description>
    </item>
    
    <item>
      <title>Rustのクロージャを理解する</title>
      <link>https://blog.take4s5i.dev/posts/2021/rust-closure/</link>
      <pubDate>Thu, 16 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.take4s5i.dev/posts/2021/rust-closure/</guid>
      <description>まずはRustのクロージャを見てみましょう。
fn main() { let nums: Vec&amp;lt;i32&amp;gt; = vec![1,2,3,4,5]; let y: i32 = 2; let iter = nums .into_iter() .map(|x| x * y); for x in iter { println!(&amp;#34;{}&amp;#34;, x); } } 出力:
2 4 6 8 10 |x| x * y の部分がクロージャですね。 パット見単純そうに見えますが、他の言語のクロージャと同じように使おうとするとRustのライフタイムや所有権で躓きます。
例えば以下のコード。 クロージャの入門としてよく使われている？呼ばれた回数をカウントする関数ですが、これはコンパイルできません。
fn counter () -&amp;gt; Fn() -&amp;gt; i32 { let mut x: i32 = 0; return || { x += 1; x } } fn main() { let c = counter(); println!</description>
    </item>
    
    <item>
      <title>[Rust] panic を理解する</title>
      <link>https://blog.take4s5i.dev/posts/2021/rust-understanding-panics/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.take4s5i.dev/posts/2021/rust-understanding-panics/</guid>
      <description>panicしたら異常終了するぐらいにしか理解していなかったので。 いろいろ調べたり実験したりしてみました。
panic したときの挙動 #[derive(Debug)] struct Data(u32); impl Drop for Data { fn drop(&amp;amp;mut self){ println!(&amp;#34;drop {:?}&amp;#34;, self); } } fn call_recurse(n: u32) { if n == 0 { panic!(&amp;#34;panic!&amp;#34;); } let data = Data(n); call_recurse(n - 1); println!(&amp;#34;return: {:?}&amp;#34;, data); } fn main() { call_recurse(4); } 出力:
 Compiling playground v0.0.1 (/playground) Finished dev [unoptimized + debuginfo] target(s) in 1.07s Running `target/debug/playground` thread &#39;main&#39; panicked at &#39;panic!&#39;, src/main.rs:12:9 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace drop Data(1) drop Data(2) drop Data(3) drop Data(4) Drop トレイトを実装した構造体の生存中にpanicしたところ、ちゃんとdropされました。 この挙動はunwindingというようです。</description>
    </item>
    
  </channel>
</rss>
